位置ベースの移動
今、behaviorに
「this.position.add(this.velocity)」
使ってるけど、これを選択式にして、デフォはこれでいいとして、これとは別に、たとえば、
「
  this.position.x = this.move.r * cos(this.move.angle) + this.move.cx;
  this.position.y = this.move.r * sin(this.move.angle) + this.move.cy;
  this.move.angle += this.move.angleSpeed;
」(rを増やせば螺旋もらくらく)
みたいに、位置ベースで・・this.moveには動きを表現するパラメータが入る感じ。他にも、
「this.position.x += this.move.vx, this.move.vx += this.move.ax」
的な？そういうのを・・んー。
shotDirectionはこれとは別に。directionがないと表示の時に困るけどそれは適宜計算するのもあり・・とか？

class FireCommand{
  constructor(fireSeed, dict){
    if(fireSeed === undefined){ this.fire = createFirePattern({}); }
    else{
      const fireData = interpretNestedData(fireSeed, dict);
      this.fire = createFirePattern(fireData); // 変更
    }
  }
  execute(unit){
    this.fire(unit);
    unit.actionIndex++;
    return true;
  }
}

衝突判定の手順
colliderを各オブジェクトに用意する（この場合UnitとSelfUnitに必要）、Shapeから設定できそう。
colliderの衝突を判定する関数を用意する。quadTreeも用意する。
colliderの更新が出来るようにする。
colliderとは別にフラグを設けて事前に計算を回避できるようにする（ENEMY_BULLET同士は当たらないとか）。
メインループにquadTreeの更新やらいろいろ組み込んで・・あとはまあ、色々と。

未指定の場合、ノードユニットをDEFAULTにして、撃ちだすユニットはENEMYにする。
ENMEYだけ指定する場合、ENEMYで、撃ちだすユニットをENEMY_BULLETにする。
両方指定（たとえばENEMYがENEMYを作るとかDEFAULTがDEFAULTを作るとか・・）のときは両方参照する。
こういう場合は一番多い場合をデフォルトにするのが定石。でないといちいちめんどくさい。

画面外で消えるときはcollisionFlagをOFFにしよう。
パターンチェンジでunitを抹消するときもcollisionFlagをOFFにしよう。
NOTHINGやめてOFFにする。了解！

OFFにすれば余計なパーティクルが出現するのを防げる・・だいぶかけ離れたコードになってしまったが。
衝突判定、実装間近。なんとかしようね。
先にナイーブで実装して遊びたい・・・
今から作るやつ：
colliderの実装、更新処理追加、衝突判定の関数も作る。
playerのcolliderとunitの全colliderを持ち寄って、
枠内でvanishFlagがfalseでかつhideがfalseであったら木に放り込む、
ごっつんこしたところでフラグ処理でえり分け、ぶつかるようならcollider同士の判定関数でT/F.
Tならhitということでhitしたらどうするかの関数に処理を任せる。そういう流れ。
ナイーブならたとえばHPとダメージを適当に設定して総当たりでいける。
・・・総当たり？？たとえば600だとして600x599/2。。
これを減らすためにあれ、ENEMY_BULLETとPLAYER_BULLETを分けてたんよね・・でもなぁ、どうしようかな。
結局区別ないわけで、ね。まとめて扱った方が楽に決まってる。だからもうそこは突っ込まない方向で。
だってね、最終的にはそういう感じになるんよね。
ナイーブで総当たりするならそこらへん分ければ済む話だからそっちからやろうかね。んー・・乗り気しないが。

たとえば敵が10でこっちの弾丸が200の場合200x10になるし。敵の弾丸が400なら400x1.
たしても2400にしかならない、だから総当たりの方が圧倒的に速いかもしれないね。
ただこの場合、全部に対して例の円と円の距離判定をしないといけないからすごくめんどう・・。

あー、このvalidationのところでcollisionFlagを参照してえり分ける・・
bulletは当たった瞬間に消えるようにしたい。その分ダメージが入る的な？で、ゲージ表示して減る、的な？
PLAYERのHPは左上とかに出しといて・・ENEMYはすぐ下、ハナビィみたいに・・んー、考える。
受けた方はHPが減る。
PLAYERの場合にHPが0になったらどうのこうの追加せな・・
ENEMYの場合にデフォルトビヘイビアに「HPが0になったらvanish!」って追加・・
damageとhpができるわけね。
addActorsねぇ・addActorでいいんだけどね。addActorの際に、だからプレイヤーの移動範囲を若干狭めて、
当たり判定がはみ出さないようにする。で、playerにせよunitにせよcolliderのカバーレクトが画面内に
収まる場合だけaddActorする。たとえば画面外の敵には攻撃が当たらない。これは自然よね。画面内にいる時しか
当たらないわけ。そういう感じで。そういうのしか、入れない。で、colliderは毎回updateする。以上～。


やられたときにどかーん、のイメージ。
parentを使ってcircularを書き直しています。
parent使えばいいのではないかと。まず、衝突判定のタイミングをactionの直前にし、vanishFlagが立っているときは
actionを実行しないように仕様変更する。そのうえで、commandとして、parentにvanishFlagが立ったら位置をparentに
合わせてindexを増やして処理を抜けるっていうのを作る。こうすればやられた瞬間にセットした弾丸が発射される
(それまではhide:trueなどで隠しておく)。なお、その直後にparentはvanishして赤の他人になってしまうのでそこら辺は
注意しないといけないけどね。

shotDirectionの設定でfromParentを用意・・親の位置から自分の位置に向かうベクトルにいくつか足した値を
shotDirectionにしたいときに使う。
