STEP1:サイズを480x640に指定
STEP2:ObjectPoolとCrossReferenceArrayを用意する
STEP3:ObjectPool用のダミーオブジェクトを用意する
STEP4:Pキーでポーズ/解除できるようにする
STEP5:プレイヤーをおいて動かしてみる（成功）
STEP6:entityを用意してplayerはそれ経由でいろいろやる。
あと、bulletはすべてここに持たせることにする。めんどうだから。

hide:一定時間速度の方向に進むが見えない、よって当たり判定もない。終わるとshowする
wait:一定時間速度の方向に進む。終わると次の処理。
vanish:自分を消す、Poolに戻すのと配列から無くすのと両方やる必要が。

bulletのふるまい
cannonのふるまい
おわり。

頭の中でごちゃごちゃ考えて全部実現させよう出来る限りスマートにやろう
それは無理。わかってる。
だから、ひとつひとつコツコツ行こうと思うんだけどね。
それだと限界があるんじゃないかって思っちゃうと足が止まる。そして分からなくなるんだよね。
実際もう既にいくつも尻切れトンボで放り出しちゃってるんでね。

たとえばすべてのbulletは直進して画面外で消えるだけってやっても相当いろいろなパターンが実現できるのに。
それをやらないのかっていう。
多分それで突き進んでいったあとでそれやろうとすると無理ってなっちゃうのが怖いらしい。
加速とか今いろいろ考えても仕方ない、

で、撃ち方にしてもnwayとradialだけでもいろいろ・・んー。一定間隔で・・

あるフレームに発射するパターンの・・1発なのか複数か、複数だとしてどんな風なのか、とか。
nwayとline. lineはnwayの速さバージョン。
方向は固定なのか変化するのかとか・・

ていうかjsonだかyamlだか知らないけどあれをあれにするのめちゃ面倒な気がする・・・
だから自分はArray方式でいいです。楽譜方式で。その方が楽でしょ、多分。
・・・・

if(frameCount % 10 === 0){
  const initialAngle = (frameCount % 360) * 10;
  for(let i = 0; i < 30; i++){
    let ptn = {initialize:setParam(width / 2, height / 4, 4, initialAngle + i * 12), execute:go};
    createBullet(ptn);
  }
}

・・今作ったのはradial12の速さ4でさらにangleChangeが毎フレーム+10でさらに
これが10フレームに1回だからつまり角度は100ずつずれている感じ。
これを、Cannonにやらせる？？

if(frameCount % 8 === 0){
  for(let diff = -10; diff <= 10; diff += 10){
    const pos = {x:width / 2, y:height / 4};
    const dir = getPlayerDirection(pos);
    let ptn = {initialize:setParam(pos.x, pos.y, 9, dir + diff), execute:brakeAccell(60, 0.05, 0.1)};
    createBullet(ptn);
  }
}

// waveパターンはこれでいいだろ。打ち出し方向の変化。まあいろいろあるだろうけど。
if(frameCount % 4 === 0 && frameCount % 80 < 60){
  const direction = getPlayerDirection({x:width / 2, y:height / 4}) + sin(frameCount * 4) * 30;
  let ptn = {initialize:setParam(width / 2, height / 4, 6, direction), execute:go};
  createBullet(ptn);
}

// ブレーキアクセル。エイム機能を付けてみたよ。
if(frameCount % 16 === 0){
  for(let direction = 90 - 30; direction <= 90 + 30; direction += 10){
    let ptn = {};
    ptn.initialize = setParam(width / 2, height / 4, 12, direction)
    ptn.execute = brakeAccell(60, 0.05, 0.2, true, 15);
    createBullet(ptn);
  }
}

aim作ったけどこれでいい気がするしよくわかんないな。setParamで足りるだろ。

bulletにセットするpatternがなんかinitializeとexecute持ってて
executeをupdateで実行しているのね。initializeはセットするときに発動していますね。ほーう。

今作ってるのは弾丸の基本的な挙動ですね、これからいろいろ・・んー。
nway(基本方向に対してintervalごとn発), radial(基本方向を含む円形放射状), sweep(基本方向に方向を変えながら一定時間),
sweepにはnoiseを使ったものと普通に正弦波を使ったものとあって片側までで終わるのとか
そういうのってパターンありきだから関数でいう所の1段階上っていうか高級みたいな感じ。
まあ基本はgoだけど。goのnway, goの・・・

// Destinyのような何か。これもbulletPatternの差し替えできるからある意味コンポジットの高級なのよね多分。
// 3WAYとかとも組み合わせられそうな。
if(frameCount % 60 === 0){
  let direction = getPlayerDirection({x:width / 2, y:height / 4});
  for(let i = 0; i < 64; i++){
    let distance = random(160);
    let angle = random(360);
    let x = width / 2 + cos(angle) * distance, y = height / 4 + sin(angle) * distance;
    let ptn = {initialize:setParam(x, y, 12, direction), execute:brakeAccell(30, 0.05, 0.2)};
    createBullet(ptn);
  }
}

// 要らないかな・・
function wave(period, angleChange){
  // periodで方向が元に戻る感じ。
  return (_bullet) => {
    const checkFC = _bullet.properFrameCount % period;
    if(checkFC < (period / 4) || checkFC >= (period * 3 / 4)){
      _bullet.direction += angleChange;
    }else{
      _bullet.direction -= angleChange;
    }
    _bullet.setVelocity(_bullet.speed, _bullet.direction);
    _bullet.position.add(_bullet.velocity);
  }
}

// curving. カーブ。これと発射台の移動を組み合わせると面白い軌道になる。
if(frameCount % 4 === 0){
  let ptn = {initialize:setParam(width / 2, height / 4, 6, 90), execute:curving(0.5)};
  createBullet(ptn);
}
// waving. 揺れながら進む。発射方向をいじると面白そう（90のところ）
if(frameCount % 4 === 0){
  let ptn = {initialize:setParam(width / 2, height / 4, 6, 90), execute:waving(2)};
  createBullet(ptn);
}
// レフトアークガン。もういいでしょ。
if(frameCount % 4 === 0){
  let ptn = {initialize:setParam(width / 2, height / 4, 6, 90), execute:arcGun(10, 30, 10)};
  createBullet(ptn);
}
// decelerateのあとホーミングになり一定フレームでvanish
// 失敗作感がすごい
if(frameCount % 8 === 0 && frameCount % 100 < 40){
  let ptn = {initialize:setParam(width / 2, height / 4, 9, 90), execute:homing(0.05, 3, 180, 30)};
  createBullet(ptn);
}

// 思い出した。んーと、何か出した後で、waitするってやつ。パターンの中に含めるんじゃないかと。
// loopもある意味コンポジット・・同じことを繰り返し。

cannonにとりかかる。

関数の無限ループ化っていうけど普通にセットしておけば普通にループになるから無意味。
何のためにやるかって言ったら一連の流れを繰り返し行わせたいからそうするんでしょ・・。
function endless(funcArray, count, wait){
  funcArrayをすべて実行するのをcount回→waitだけおく→最初に戻る
}
function limited(funcArray, count, wait, loopCount){
  loopCountだけやったら終了するんだけどそのあとどうしよう（詰）
}
たとえばここに
- setSpeed:2
ってかくとデフォルトを変更できる
- endless
  - loop
    - count:2
    - setSpeed:random(3, 6)
    - setDirection:random(0, 360)
    for example: - setPos("relative", random(20, 120), random(0, 360))
    指示がなければspeedは1だしdirectionは0だしposは自分の位置になるよ(default)
    - fire:"unit"

cannonにとりかかりたいんですけど

endlessは毎フレーム中身のfuncを実行するだよ。でもそれだと普通にfuncでいいじゃんね。

4フレームに1回、accelerateを繰り出す、方向は90で固定、速さは3で固定・・？
- setSpeed:3
- setDirection:90
- endless
  - loop
    - countのデフォルトは1.
    - pattern
      - type:"accelerate"
      - acceleration:0.2
      - wait:3

毎回方向を変える場合
- setSpeed:3
- endless
  - loop
    - count:1
    - setDirection:
      - type:random
      - range:[60, 120]
    あるいは自機狙い
      - type:"homing"
      - margin:デフォルトは0
    - pattern
      - type:"accelerate"
      - acceleration:0.2
      - wait:3

方向が変化する場合
DirectionChangeがある場合はそれを足すみたいなやつ。デフォルトは0.
- setSpeed:3
- setDirection:60
- endless
  - fArray:[setDirectionChange(2), "sweep", setDirectionChange(-2), "sweep"}]
  文字列の場合は親[文字列]が関数になってるのでそれを見てね
- sweep
  - loop
    - count:12
    - pattern
      - type:"go"
      -wait:3
  - wait:12

  思うんだけどこの-をつなげるのってどう・・

  (_cannon) => {
    const fc = _cannon.properFrameCount;
    if(fc % 4 === 0 && fc % 60 < (12 * (3 + 1))){
      let ptn = {initialize:setParam(_cannon.position, _cannon.bulletSpeed, _cannon.bulletDirection), execute:go}
    }
  }
  が、sweepに入ってる。
  DirectionChangeはデフォルトが0でこれはupdateで毎回行うので問題ないです。
  bulletの方にも、その要素があれば実行するように指示しておいて・・こういうのはリセット時に破棄したいね（delete使う）

  バーストでちょっと使うだけだけど。

  ・・・

yamlっぽい書き方にこだわる必要はないことが分かった。あれ相当やばいよ。やめとこう。
とりあえずわかったのは-をつなげると配列になるらしいと。要するに配列じゃん。


go と goを1発だけ発射するメソッド っていうのは分けないといけないので・・

bulletに設定するptnっていうのはxとyとspeedとdirectionとexecute関数の他にあとなんか・・んー。option?
optionプロパティがあるならそれを実行するみたいな。

// waveガトリング。ごめんなさい記法が変わりました。
// まあsetParam関数を無くしただけだけどね・・
if(frameCount % 4 === 0){
  let direction = noise(frameCount / 16) * 60 + 60;
  let ptn = {x:width / 2, y:height / 4, speed:6, direction, execute:go};
  createBullet(ptn);
}

arcGun使えばみつまたのやりが簡単に作れる（FALさんのアレみたいなショットが作れる）

// 今現在のバリエーションはこちら：
if(frameCount % 30 === 0){
  let ptn;
  ptn.set = {x:width / 2, y:height / 4, speed:8, direction:90};
  //ptn.execute = go;
  //ptn.execute = accellerate({accelleration:0.1});
  //ptn.execute = decelerate({friction:0.02, terminalSpeed:3});
  //ptn.execute = brakeAccell({threshold:60, friction:0.02, accelleration:0.2, aim:true, margin:10});
  //ptn.execute = curving({directionChange:0.4});
  //ptn.execute = waving({friction:2});
  //ptn.execute = arcGun({threshold:20, diffAngle:20, aim:true, margin:10});
  ptn.execute = homing({friction:0.05, terminalSpeed:3, life:180});
  createBullet(ptn);
}

// ようやくjsonというかオブジェクト1個からbulletを生成する目途が立った気がする
let data = {name:"accellerate", set:{x:width / 2, y:height / 4, speed:6, direction:90}, param:{accelleration:0.2}};
let ptn2 = {set:data.set, execute:window[data.name](data.param)};
createBullet(ptn2);

// でも連続パターンがまだだ・・・・

let ptn = {x:width / 2, y:height / 4, execute:()=>{}};
createCannon(ptn);
testCannon = entity.cannonArray[0];
testCannon.config({type:"set", speed:5, direction:90})

executeはそのうち何とかする予定。
testCannonでfireのtestをしています。

// こんな感じ、fireに引数渡すだけでいろいろあれできるじゃんね。diff使ってみる。
if(frameCount % 4 === 0){
  //testCannon.fire({name:"go"});
  //testCannon.fire({name:"accellerate", param:{accelleration:0.2}});
  //testCannon.fire({name:"decelerate", param:{friction:0.05, terminalSpeed:2}});
  //testCannon.fire({name:"curving", param:{directionChange:1}});
}

// diffのところに{direction:~~~}って書いて5WAYGUN作ってみました。いけてるね。
if(frameCount % 4 === 0){
  const count = 5;
  const interval = 10;
  for(let i = 0; i < count; i++){
    testCannon.fire({name:"go"}, {direction:(-(count - 1) / 2 + i) * interval});
  }
}

// だからこれでループ生成と組み合わせれば、っていうか・・まあ、いける？

// 最初の例できたかも
if(frameCount % 1 === 0){
  for(let i = 0; i < 2; i++){
    testCannon.config({type:"set", speed:randomRange([3, 6]), direction:randomRange([0, 360])});
    testCannon.fire({name:"go"});
  }
}
// これをexecuteに落とせばいいのね。3フレームに1回で
{count:2, funcArray:[{name:"config", param:{speed:[3, 6], direction:[0, 360]}}, {name:"fire", data:{name:"go"}}]}とか？
これでこの内容を毎フレームやることになればいいんだけど。
で、やったあとにたとえば2フレーム間を置きたい場合は、wait:2とかそういうのが要る？
{count:2, funcArray:[...], wait:2}
でいいんじゃない・・わかんないけど。executeに関数が入る、その関数を決める、んだけど。
nameは_cannonの実行する関数・・んー。

ということは基本的にconfigとfireだけで記述していくことになる？
まあ他に要るかと言ったら・・

burstで4WAYとか作れるの？
基本的なburst, というかbulletがbulletを作る機構について。どうも種類くらいあるようで。
まずその場で消滅して何かしらのパターンに基づいてbulletを作る場合。これは、paramの中にそこら辺の
情報が詰まってて場合によってはそれを利用してとかそういう流れ。

behaviorリストの考え方を使って画面外で消滅のくだりをbehavior化してとかそういうのはたやすいし
時間が経ったら消えるのとかあるいはCannonの移動に関する挙動もそれで出来るのはいいんだけど
burstもそれでやる場合例えば{trigger:~~~, pattern:~~~}のpatternで速度とかどうするんだって話になるのよ。
triggerに含める？bullet用のbulletSpeedやbulletDirectionについてのあれこれを。
もしくは、ああそうか、bulletの場合はCannonと違って独自の速度があるから基本的にそれ使って、
つまりCannonのbulletSpeedやbulletDirectionの代わりにそれ使って、diffだけ指定すればいいかな・・
diffが無ければ同じものを使うようにすればすっきりしそう。
一番小さいかたまりでないとexecuteに入れられない
あそこに実行内容の配列とか入れても仕方ないでしょ。
{
  name:"loop",
  count:2,
  funcArray:[{name:"config", param:{type:"set", speed:[3, 6], direction:[0, 360]},
             {name:"fire", param:{data:{name:"go"}}}],
  wait:3
}

_cannonが持っている引数をparamとする関数を色々実行するのを指定回数だけ行うってやつ

function createLoop(obj){
  return (_cannon){
    if(frameCount % obj.wait > 0){ return; }
    for(let i = 0; i < obj.count; i++){
      obj.funcArray.forEach((obj) => {
        _cannon[obj.name](obj.param);
      })
    }
  }
}

// あーそうか、fireでこれこれこういうのを一発撃ちますっていう話なのか。3wayとかそういうのは・・ね。


{name:"endless",
  actArray:[{うえのやつ}, {name:"wait", count:3}]
}
[{}, {name:"wait", count:3, limit:8}, {name:"wait", count:24}]
 ってやると、
 (_cannon) => {
   const fc = _cannon.properFrameCount;
   if(fc % 4 === 0){
     for(let i = 0; i < 2; i++){
       _cannon.config({speed:randomRange([3, 6]), direction:randomRange([0, 360])});
       _cannon.fire({name:"go"});
     }
   }
 }
 ができる？executeにはこれを入れる。
 別の考え方。
 executeには二つの関数が入る可能性がある。
 1つ目：
 (_cannon) => {
   const fc = _cannon.properFrameCount;
   for(let i = 0; i < 2; i++){
     _cannon.config({type:"set", speed:randomRange([3, 6]), direction:randomRange([0, 360])});
     _cannon.fire({name:"go"});
   }
   _cannon.waitCount = 3;
   _cannon.next();
 }
 2つ目：
 (_cannon) => {
   if(_cannon.waitCount > 0){ _cannon.waitCount--; }
   if(_cannon.waitCount === 0){
     _cannon.next();
   }
 }
 この二つが切り替わる感じになる。f0, f1と名付けて・・[f0, f1]
 f0終了時に判定
 waitCountに3を設定して次

 // radialって発射位置の相対位置もずらすんだ？たとえば本体から右下でこれを3radialするなら
 その位置ベクトルも回転させないとおかしなことになる、directionベクトルだけじゃだめってことね。なるほどー。
 難しいね。でも発射位置のベクトルずらすだけなら簡単そう。diffは・・diffもradiusとdirectionに分けるべき？うん。
 やめとこうか・・・んー

// delayGunやめてdelayをプロパティにした。その方がすっきりする。
// 横一列に並べて一気に向かってくる感じ。
if(frameCount % 4 === 0 && frameCount % 720 < 360){
  let x = Math.floor((frameCount % 720) / 4) * 4 + 60
  let ptn = {x:x, y:120, speed:12, direction:90, delay:60,
             execute:homing({friction:0.05, terminalSpeed:2, life:180, margin:0})};
  createBullet(ptn);
}

 一度に発射する感じのパターンをいくつも組み合わせるっていうのを今考えてるんだけどなんかうまくいかない。

 とりあえず今んとこ作ったパターンから、とりあえず一定間隔で発射するやつだけ作る・・
 なんかもうそれ作るだけで精一杯やー。

 nway, directionに回転かけるだけだと思ってたけど、diffにもかけたほうがいいよね・・radialもそうすべき。
 // ということはdiffはdiffRadiusとdiffDirectionからなるって感じですかね。
 nway, radius, lineはそういうパターンの複製を行うものと認識してる。あとburstとか。これも、
 全体に付与するからそういうの。

 formationでしょ、diffって。円形と扇形とラインくらいしか思いつかないけど。ラインは横、縦。間隔。

 順序。
 まず速度を決めます（speedとdirection）
 次にフォーメーションを決めます（自分の所に1個、円形に8個、みたいなやつ）
 ここで位置を相対位置として決めておいて一番最後にCannonの位置を足し算する感じですかね。それでxとyが決まる。
 (ディレイがある場合はここで設定。用意しない場合もあるけど。
 たとえば横一列に並べて中心ほど早くするとかそういうの。
 やり方は線型ディレイとかそんな感じでオプションを考えて順番を考慮するだけ)
 (同心円状に並べて外側程早くする（言ってみただけ(それradial組み合わせればできるやん)）)
 次に位置と速度についてのnwayやらradialやらlineやらのオプションを決めて適宜bulletを増やします
 （nway:角度を適宜回転、diffDirectionも適宜回転して複製。
   radial:角度についてそれをn分割の方向にして複製、diffDirectionも同じく。それを角bulletに行う。
   line:各bulletについて速さをある程度等間隔に増やしながら複製、etc...）
 bulletPatternが出そろったのでCannonの位置座標からxとyをまとめて全部最終的に決定します。
 まとめて弾丸の挙動パターン関数(execute)を指定します。
 複製の時は元のやつを破棄して新しく必要個数のオブジェクトを作るのでプロパティは少ない方がいいよね。
 次に発射の間隔を決めます。
 完成！！
 これだと途中で分裂する弾が撃てない？知らん！！！
 ある程度連射した後のwaitが命令できない？waitCount増やせばできるでしょ。「完」
 複数のパターンを併用したい？もう配列にして毎フレーム実行しちゃえ！！！「完」

 この辺をjsonに落としてCannonにぶち込むのがひとつ。
 そして実行に関しては完成した・・あー・・・なんかおかしい？

 そうか、これ1回の間に実行するやつだ。これでひとかたまり。
 また、最初の速度指定の所でCannonのbulletSpeedとbulletDirectionを使うんですね分かります。
 さらに毎フレーム実行する方向変化のオプションとか組み合わせてノイズや回転を表現できる。OK!
 つまりパターン定義のjsonとは別にCannonのふるまいを決めるjsonを作るのね。それはいいんだけど・・・

 あー、じゃあ発射間隔とかそういうのは別の話になるかな・・毎フレームのあれとかそういうのも含めて。
 たとえば毎フレームランダムに変わるのとかそういうのとか。
 じゃあとりあえずそこらへん作ろう。

 1.フォーメーションで相対位置を指定しつつ配置（デフォルトは0,0に1個だけ）
 1.5 bulletDirectionでフォーメーションを回転させて撃ちだす方向に合わせる感じ。
 2.あればディレイ
 3.同じ速度を設定
 4.あればnwayやらなんやらで複製
 5.まとめてCannonの位置を加えてパターン完成
 6.まとめてexecute関数を設定
 7.まとめてcreateBulletに放り込む。以上。
 これらの情報をjsonに落としてloopに埋め込んだらOK.

 set:{}の{}を作るのが5までで、そのあとそれをsetに落として6,7を実行すると。

 これでできるのは
 (_cannon) => {なんかいろいろやってそのあとcreateBullet}っていう関数ですね。
 その前にsetとかaddでbulletDirectionとかいろいろ変化する感じ。
 だからまずはjsonで書かれたこのレシピを関数にする関数が必要で、
 さらにそのjsonが埋め込まれた行動ルーチンを表現するjsonを
 (_cannon) => {いろいろやろう}
 って感じに解釈する関数が必要なのね。

 ・・よくわかんないけど、番号の付け方にパターンを付ければいい・・
 今色々考えても仕方ないじゃん。とにかく作らないと始まらないよ～～
 右から順番とか左から順番とか真ん中から・・とかそういうの。で、あとは等差数列・・
 一般化等差数列：floor((an+b)/c) + d
 どうも中心から外側に向かって9, 8, 8, 7, 7, 6, 6, 5, 5, みたいにdelayを掛けたいらしい。

 さてと

 setやめよう。普通に{x:y:speed:direction:delay:execute:}でいいよ。


// 遊び過ぎた（（
 let fireData = {
   formation:{type:"frontVertical", distance:30, count:4, interval:20},
   name:"go"
 };
 let fireFunc = createFirePattern(fireData);
 let func = (_cannon) => {
   const fc = _cannon.properFrameCount;
   _cannon.setPosition(240 + 120 * sin(fc), 160);
   if(fc % 4 === 0){
     _cannon.config({type:"set", direction:noise(fc / 8) * 30 + 75});
     fireFunc(_cannon);
   }
 }
 let ptn = {x:width / 2, y:height / 4, bulletSpeed:12, bulletDirection:90, execute:func};
 createCannon(ptn);
}

// 回転しながらばんばん
// よけられねぇ・・・
let fireData = {
  formation:{type:"frontVertical", distance:60, count:2, interval:20},
  radial:{count:12},
  name:"go"
};
let fireFunc = createFirePattern(fireData);
let func = (_cannon) => {
  const fc = _cannon.properFrameCount;
  if(fc % 4 === 0){
    _cannon.config({type:"add", direction:5});
    fireFunc(_cannon);
  }
}
let ptn = {x:width / 2, y:height / 4, bulletSpeed:4, bulletDirection:90, execute:func};
createCannon(ptn);
