パターンの作り方（現時点）
{
  x:Cannonの初期x座標,
  y:Cannonの初期y座標,
  speed:Cannonの初期bulletSpeed(任意),
  direction:Cannonの初期bulletDirection(任意),
  action:[行動配列(作り方は後で)],
  short:{行動配列のショートカット},
  fire:{発射パターンについて}
}
actionの各セグメント
{wait:n} nカウントの間何もしない
{type:"fire", name:発射パターン名} 同じパターン名のfire内のプロパティが生成する関数に従って発射
{type:"config", mode:"set"もしくは"add", speed:任意、direction:任意}
bulletSpeed, bulletDirectionをsetまたはaddに従って操作する。setは値指定、addは加える。
setの場合は配列にする（[a]でa,[a, b]でaからbまでのどれか、[a, b, i]でaからi刻みでbまでのどれか）
{type:"aim", margin:任意}
bulletDirectionをmarginの範囲で自機狙いに切り替える。
{type:"vanish"}
消滅するフラグを立てる（bullet用）
{repeat:~~, back:~~} repeatの回数だけインデックスをbackだけバックする、同じターン内の繰り返し。
{loop:~~, back:~~} loopの回数だけインデックスをbackだけバックする、これはバック時にターンを抜ける。
無限ループの場合はloop:Infinityとする感じ。

今んとこ、こんな感じ。2019/12/22(冬至)

パターン1:
{x:240, y:320, speed:2, direction:90,
action:[
{type:"config", mode:"add", direction:2}, "routine", // 略記法・・配列が入ってるので展開して放り込む。
{type:"config", mode:"add", direction:-2}, "routine",
{loop:Infinity, back:10}],
short:{routine:[{type:"fire", name:"radial16"}, {wait:4}, {loop:8, back:3}, {wait:16}]},
fire:{radial16:{radial:{count:16}}}
};
パターン2: (最初のやつ)
{x:240, y:160,
action:[{type:"config", mode:"set", speed:[3, 6], direction:[0, 360]}, {type:"fire", name:"u"}, {repeat:2, back:2}, {loop:Infinity, back:3}],
fire:{u:{}}
};

バーストどうする？
lineの実装より先にバースト作りたい。lineもいいんだけどね・・

あそこさ、たとえば、{type:"config", content:["add", "-", 2]}とか書けないの？
パーサーにそこら辺・・要するに、typeかwaitかrepeatかloopしかないわけで、そこら辺。
つまりtypeに関してはここを配列にする、無いところは"-"でおいとく、的な？通すときに翻訳してオブジェクトにできたらいいね。
と・・？
{x:240, y:320, speed:2, direction:90,
action:[
{type:"config", mode:"add", direction:2}, "routine", // 略記法・・配列が入ってるので展開して放り込む。
{type:"config", mode:"add", direction:-2}, "routine",
{loop:Infinity, back:10}],
short:{routine:[{type:"fire", name:"radial16"}, {wait:4}, {loop:8, back:3}, {wait:16}]},
fire:{radial16:{radial:{count:16}}}
};
→
{
  set:[240, 320, 2, 90],
  action:[["config", "add", "-", 2], "routine", ["config", "add", "-", -2], "routine", {loop:Infinity, back:10}],
  short:{routine:[["fire", "radial16"], {wait:4}, {loop:8, back:3}, {wait:16}]},
  fire:{radial16:{radial:{count:16}}}
}
説明・・
setはセットする、セットしないところ（スピードとか）は"-"を入れる。
こんな感じ
{
  set:[240, 160, "-", "-"],
  action:[["config", "set", [3, 6], [0, 360]], ["fire", "u"], {repeat:2, back:2}, {loop:Infinity, back:3}],
  fire:{u:{}}
}
ここから復元できるようにしたい。
そうすれば、たとえばvanishなんかは["vanish"]で済むようになる。["set", "align"]で簡単に「bulletが作るbulletの速さと
向きをそのまま同じもので固定」できるし。バーストに一歩近づくでしょ。

翻訳した先を従来と同じものにすれば何の問題もない。

""ではなく"-"を採用するのはどうしてかって？
0 == ""がtrueになるからに決まってる・・0 === ""はfalseなんだけど。"-"なら0 == "-"でもfalseだから打ち間違いで
バグになるのを防げる。だから""ではなくちゃんと数字になりえない"-"を採用するわけ。

どうするかな・・
はじめにsetプロパティをみて順繰りに。"-"は無視。
次に再帰で崩すところは変更しなくていい。
配列が出来た後で、各成分について実行するにあたり、interpreterで配列を然るべきオブジェクトに変換する(typeとかnameとか
speedとかなんかそういうの)。waitやrepeatやloopについての処理はそのまま残す。というかwaitはそのままか。それ以外。
0番目がtypeで、あとはtypeによって場合分け。

パターンの作り方（改訂版）
1.初期設定。
set:[x, y, speed, direction]の形式で指示する。指定しない場合（speed, direction）は"-"をおく。
2.actionのところ。行動配列を置く。
各成分は配列もしくはオブジェクトもしくは文字列。
文字列はshortの先にそれを置くことで展開してパターンにする。
オブジェクトの場合：{wait:40}とか{repeat:3, back:4}とか{loop:8, back:10}とか。
このback:-1で先頭、とかできたらいいね。
配列の場合は実行内容を["config", "add", "-", 5]とか["config", "set", [3, 9], [60, 120]]みたいにしてセットする。
どうかな・・addもそういう風にするか？たとえば、スピードを-5~5の範囲で摂動させるとか。
だったらあっちもrandomRange型にして具体的にあれする場合は[5]とかにするといいね。
fireの場合は["fire", "radial16"]とかして"radial16"はfireプロパティの先に関数を用意しておく感じ。
back:-1で先頭、は即採用。うん。




まずburst作るとしたら手を加えるのはcreateFirePatternのdataんとこ
_cannon.bulletBurstに・・
今this.pattern.execute(this)とあるところをthis.pattern."move"(this)とする。毎フレーム実行する移動についての関数。
で、あー・・actionとは別にこれ用意したほうがよさそうだな・・
moveの方も配列にした方がいいかもだけど一考の余地ありっていうか。下手したら以前と同じように、
ちぐはぐに両方定義して云々連携がどうたらこうたらってことになりかねないから怖いんだよ。あれはひどすぎた。

speedの代わりにshotSpeed, directionの代わりにshotDirectionにするかー。
なぜかというと自身の速度の変化とかも考慮する必要が生じてきそうだからそこら辺を区別したいっていう。
あとあれ、configだと分かりづらいからshotSpeedChangeとかshotDirectionChangeとかにしたいかな。
そうすれば自身の方はspeedChangeとかdirectionChangeとかにできる。
addBehavior("go")とか。behaviorに「速度を位置に足せ！」を追加する。
behaviorは必要に応じてaddやremoveできるように、それをactionで制御し、なおかつ・・

いじるか。
まずはshotSpeedとshotDirectionにするね。
次にconfigを廃止してshotSpeedChangeとshotDirectionChangeにするね。["shotSpeedChange", [3, 6]]とか・・
setでなくsetPosition:[240, 160]とかsetVelocityとかsetShotVelocity:[6, 90]とかにしたいね。

addBehavior
removeBehavior

go: this.position.add(this.velocity);
behaviorListに「直進」って加える。
「画面外で消える」って加える。
speed, direction, shotSpeed, shotDirectionをそれぞれ継続的に変化させるのもbehaviorに入るかもね。
class Behavior{
  constructor(behaviorFunc){
    this.behaviorFunc = behaviorFunc;
    this.active = true; // falseの時は実行しない
  }
  on(){
    this.active = true;
  }
  off(){
    this.active = false;
  }
  execute(obj){
    if(!this.active){ return; }
    this.behaviorFunc(obj); // ここでいろいろやる感じ。
  }
}
これだと細かい変化に対応できないよ。？逐一作るの？まあ、そうか・・
あー違う、これ・・んぁーーめんどいいい
関数、今、moveにセットしてるけど、これを、オブジェクトにする。
{name: 識別用の名前, func:bullet間で共通, active:実行するかしないか。}
nameはactivateBehavior, cancelBehaviorにおいて名前で該当するBehaviorを見つけるために必要。
funcはBullet間で共通だったり。
{name:"outFrameVanish", active:true, func:outFrameVanishBehavior}
function outFrameVanishBehavior(obj){
  if(...画面外...){ obj.vanishFlag = true; }
}
bulletにデフォルトで入ってるのはこれとgoBehaviorのみ。


behavior 案
// 部品を組み合わせる形にしたい。たとえば、・・
// curvingはあんな面白くない感。特定のパラメータ(speed, direction, shotSpeed, shotDirection)のどれかを
// 継続的に変化させるbehaviorを用意して適切にonoffする感じにするかな。
// homingあんま面白くない。やっぱ何フレームかおきに方向変化させるのがいいんじゃね。10フレームおきとか。
// 何が言いたいってこの関数群を破棄してbehaviorという関数群にしてそれをいくつか放り込む形にしたい・・
// bulletのデフォルトとして画面外で消えるってのを常におくようにしてそこに重ねていく形。
// 継続的にパラメータ変化させるっての言ったけど・・
// フレーム間隔くらいは指定してもいいと思う。そうすればactionの方を若干簡潔に出来る。リフレッシュレート
// みたいな。4フレームおきに自機方向を計算してセットするとか。毎フレームでももちろんいいね。
// ていうか毎フレームでいいのか・・毎フレーム自機方向。onoff自由自在。？

// 今現在パターン登録のところでnameとしているところをやめてbehaviorにするとか。デフォルト・・
// go:{位置に速度を足す}, frameOut:{画面外に出たら消える}
// default:0とすることでgoが勝手に入る感じ。frameOutは元から入ってる感じで。うん。うん？goでいいよ

// speedとshotSpeedがあるようにbehaviorとshotBehaviorがあってもいいんじゃない？
// speedやdirectionをセットするみたいにshotBehaviorをセットする（リセットも用意する）イメージ。
["shotBehavior", "brakeAccell", 60, 0.02, 0.1] (減衰時間、減衰割合、加速度)
ってやると。ん。
"go"は常にでいいよ。
事前にCannonを動かす場合を考えてた。たとえばgoを指定して速度をどうするとかそんなような。
bullet動かすにもそこら辺を。
クラスにすると

デフォルトはframeOutBehaviorでそこにまずgoBehaviorが入りその他って感じ。
onとかoffはとりあえず考えなくていいと思う。unShiftで先頭に入れていく。pushではなく。

流れの中でshotにどんなbehaviorを追加するのか、そのリストをaddしたりremoveしたりいろいろいじるイメージ。

やめた。オブジェクトにしよう。で、付け外し出来るようにする。
じゃないと柔軟性が・・
fireみたいにbehavior:{}
で、名前：paramでこれを解釈して名前：関数にする。
これをbehaviorにaddするときにaddならshotbehavior[名前] = その関数ってやって
外したいときはdelete shotBehavior[名前]
全部無くしたいときはshotBehavior = {}でOK.

バーストって何だっけ・・・
bulletにactionさせるだけでしょ。bullet作ってバーニッシュ(??)
shotActionってやって同じように出来るはず、問題は・・あ、ディレイどうしよ(今更)
bulletが発射するbulletは基本、発射位置がデフォルトでその位置、速度はいじらなければbulletそのまま
で変えたきゃaction使ってくださいって感じ。shotDelayも同じ。そうです。

まずbulletにもcannonと同じアレを用意する、
次にseedの中のshotActionに入れ子でactionを入れてパースして配列にする。
fireまででいい、それ以外はまあ・・ね。
んで、createBulletのときにptnにindexとactionとあとfireをセットすれば然るべく動いてくれるよ。
あとはupdateをいじるだけ。
behavior・・そこまで複雑に、できなくもないけど、まあ、要らないでしょ・・
問題は、ここまで似せちゃうともはやbulletとcannonを区別する意味が希薄になっちゃうってことね。

trigger.
loopやrepeatと同じでbackがあるんだけど、triggerには関数が設定されてて、それがtrueを返す場合に戻る。
カウントもすべて元に戻す。falseを返す場合に次にインデックスを進める感じ。
たとえばHPが低いとか、あるいは自身のスピードが高いとか。
はやくバースト作ろうよ。

{trigger:["HPMoreThan", 200], back:4}とか。hp > 200のとき戻る。
{trigger:["nearBy", 10000], back:-1}とか。プレイヤーとの距離の2乗が10000以下の時に振る舞いが変わるイメージ
あとはjumpかなぁ・・いくつかの候補の中からランダムでどれかに行くとか。
はやくバースト作れ。

やられたときになんか弾出すやつでしょ・・あれはね、behaviorにした方がいい。まあやらないだろうけど。
やりかたは2つ。ひとつは素直にbehaviorで実現する。もうひとつは、衝突判定を
actionの前にやって、トリガーでHP・・うそです。
fireの関数はどこからでもアクセス可能だからどう考えてもbehaviorで実装するべきだろ。あほか。

とりあえず、shotVelocityはvelocityが既に定義されているならそれを流用する感じにしよう・・？
違う。セットするパターンシードがvelocityは持ってるけどshotVelocityは持ってない時に
shotVelocityをvelocityにalignする処理でしょ。
shotPatternのところにシードを書いてそれをパースしたものをbulletに当てはめて
bulletにもcannonと同じようなactionの実行ルーチンをやらせるわけ。なんだけど・・んー。
今現在のbulletにセットするパターンの形：
x:~~, y:~~, speed:~~, direction:~~, delay:~~, behavior:~~
って感じ。あ、behaviorは関数配列ね。
結局moveを無くしてしまったので・・これをjsonのパースで作るとかそういう話。bulletはbehaviorで動く。
cannonもbehaviorで動かせる・・動かそうと思えば。うん。同じようにね。


めんどくさ
createFirePattern. 手を加えるのはここ。それは分かってる。
bulletはcannonと違ってcreateFirePattern関数しか作れない。その事実を使うんだろ。
parse関数はactionをshortやfire, behaviorを使って解釈する部分が独立しているからそこら辺も・・
丸写しだとマズいのは、waitとloopとrepeatの数を制御するところ。まああそこは配列の各成分をアサインで
ああしてこうするしかないわね。入れ子の時どうするかだけど。ただいちいちパースするわけにもいかないでしょ。

明日にしよう2019/12/24(Christmas Eve)
ひとつだけ。actionをshort, fire, behaviorから構成するでしょ。その際、関数で置き換わる・・あ？
action.fireに関数が入るものと思ってたのにそうなってないじゃん・・・書き換えて。
そうすればパースした後はもうfireとかshortとかbehaviorとか全部要らなくなってactionだけになるわけ。
パースの段階でほぼactionしかなくなる。
さらに、behaviorって_cannonから移してるでしょ・・
さて、cannonにセットするpatternで使うのは結局、
x, y, shotSpeed, shotDirection, (delay??), action
だけ、だからbulletについても同じだと思う。
つまり、shotPatternについてパースに使うデータを用意してそれをパースして初期段階でaction一本にする、
入れ子の場合も中身から何から何までパースして一本にする。

つまりfireもbehaviorも(fireの情報がbehaviorで使われる可能性があるし)もちろんshortも
actionを作るための付加データでしかない、
だから完成形のpatternにはx, y, speed, direction, shotSpeed, shotDirection(あとshotDelayとかdelay...)の他には
actionしか残らない、はず、なんです。
そしてその付加データにshotPatternを加えようとしているイマココ。
shotPatternにも同じようなのが入っててパースでactionになる。
イメージ：
x-------------------------|
y-------------------------|
speed---------------------|
direction-----------------|
shotSpeed-----------------|
shotDirection-------------|
delay---------------------|
shotDelay-----------------|
                          |----pattern
action----|               |
fire------|               |
behavior--|----|          |
short-----|    |---action-|
               |
shotAction-----|

action------|
fire--------|
behavior----|------shotActionの各々のactionSeedがこれらによりactionになる
short-------|

セットするパターンはxやらyやらを除いた特別な形をしている。
たとえばbulletのdelayとかは_cannonがshotDelayを持っているときそれが登録される感じ。
shotDelayをbulletが持つようなのはactionに含められる。
だからactionだけだね。それがshotBehaviorのようにcannonのshotAction={}に付け外し、
それがcreateFirePatternの中の関数で_cannon経由でbulletに登録される。
登録されたactionがbulletのupdate内で実行されると、
bulletがbulletを生成するメソッドが実行される仕組みだ。

ただこの形式だとパターンシードオブジェクトのところが煩雑になってしまうので、
shortのようにsubSeedみたくしてそこに名前経由で入れておいて展開するという手法に頼った方がいいね。

各々は["name", actionSeed(のエイリアスの文字列)]という形をしている。
コードネームがsubSeed:{エイリアス:{ここにシード}}という形で紐付けられる・・んー。
action列を正式な形にするにはfire, behavior, shotActionがすべてきちんと関数を与える形になっていないといけない
ので、そこら辺の翻訳を優先しないといけない。
shotActionの下位にあるaction列をきちんとした形にするのが先だからそこは再帰で下っていく
感じになるかな・・
今の仕組みだとaction列の翻訳がfireやbehaviorより先になってるせいで配列に関数を落とし込めていないので
だめなんですよ。

そこで・・parsePatternSeedを二つに分ける。
setとpatternかな。この。
setの中にはposition, velocity, shotVelocity, delay, shotDelayが入りうる。
behavior, patternとかはその、shotBehaviorとshotPatternだけど、付け外しするから。別に、いい。
{set:{}, pattern:{}}
patternと書くのは入れ子にするため・・あーあとひとつ。
{set:{}, pattern:{}, short:{}}
shortには短絡の為の省略形を入れておいて、どの段階のpatternの構造からでも、action内の文字列を
置き換える形で参照できるようにする。さらにshort内のそれも参照で解決できるようにする（入れ子の入れ子・・）
let seed2 = {
  position:[240, 160],
  action:[["shotSpeed", "set", [3, 6]], ["shotDirection", "set", [0, 360]], ["fire", "u"], {repeat:2, back:3}, {loop:INF, back:-1}],
  fire:{u:{}}
};
いいよ。
先に・・
position, velocity, shotVelocity, delay, shotDelayはsetに、
shortはそのまま、
それ以外はpatternに入れる(action, fire, behavior, pattern)
これが第一段階。
set:{position:[], velocity:[], shotVelocity:[], delay:[], shotDelay:[]}
short:{}
pattern:{action:{}, fire:{}, behavior:{}, pattern:{}}
これも関数にする・・
次に、set部分はいじらないで、shortの情報とpatternの情報をもとに省略部分を無くす。
下まで見ていってすべて無くす。
無くしたうえで、今度はもうshortが要らないので、こんどはfireとbehaviorを元に、actionの関数化できる部分を
関数化する。patternのところも・・
patternの入れ子は最後にはなくなる。おわり。

完成形が持ってるプロパティ
{x, y, speed, shotSpeed, direction, shotDirection, delay, shotDelay, action}
これですべて。
fireとかbehaviorはseedのその部分を関数で置き換えて最終的にはaction配列内に埋め込まれるのでこっちには残らないし
shortは略形の配列が入ってるだけだから最初に展開したら不要になる。
そのときshotPatternも展開される、
shotPatternについてはその中身から展開して、そっちはそれぞれactionになる、
action配列内のshotActionを付けたり外したりするところに関数の形で埋め込まれる（shotBehaviorと同じ）


あとね、細かいことだけどaction内の命令はshot~~~をいじるものとfireと構造関連(loop, repeat,いわゆる反復子)しかないから
["speed", "set", 7]とか["direction", "add", 5]で通じると思う。気になるなら翻訳の際に・・まあ、要らないか。
---------------------------------------------------------------------------------------
actionSegmentの分類。
bulletにセットするプロパティ関連
speed, direction, delay --- set, add --- 数または2つ,3つの数からなる配列
behavior, action --- set, remove, clear --- それらの名前(エイリアス)
発射関連
fire --- ショットの名前(エイリアス)
反復子
loop, repeat, (trigger) --- back
その他
vanish, waitなど
---------------------------------------------------------------------------------------
略形 → 実行形式
文字列操作使うのもありなんだろうけど。
自身のspeedやdirectionはメソッドで変えることはあっても直接いじることはないかな・・・
["speed", "set", 8] → {type:"speedChange", mode:"set", speedChange:8}
["direction", "add", 5] → {type:"directionChange", mode:"add", directionChange:5}
["delay", 10] → {type:"delayChange", delayChange:10} // addやsetはなく、shotDelayを10にするとかそういうの
["delay", 0] これで元に戻る。
["fire", "name(エイリアス)"] → {type:"fire", shot:関数}
["behavior", "setかremove", "name"] → {type:"behavior", mode:"setかremove", behavior:関数}
["action", "setかremove", "name"] → {type:"action", mode:"setかremove", action:命令の配列}
index付け加えるのわすれないでね
{wait:8} → {type:"wait", count:8}
{loop:4, back:2} → {type:"loop", count:4, back:2}
{repeat:4, back:3} → {type:"repeat", count:4, back:3}
{"vanish"} → {type:"vanish"}(たとえばvanish:30とかして30が0になったら消えるとかね。)
{"aim", 30} → {type:"aim", margin:30}
とりあえずこのくらい・・type使おう。

{speed:["set", 8]}とかする。全部オブジェクトにしたい。配列無くしたいの。
{direction:["add", 5]}とかね。
{delay:10}とか{delay:0}の方が分かりやすいでしょ。
{fire:"name"}{behavior:["set", "name"]}

それと、できたらだけどcountをなくせたらなくしたい・・・・スタックでなんとか
まずね
repeatは？抜けないだけじゃないの・・知らないけど。
まずfireするでしょ、次行くでしょ、からっぽかもしくは先頭が正の場合に0をpushして1ふやして<4だから出る
1→2で<4
2→3で<4
3→4で<4を満たさないからそれを外して
waitって何をするの
fireのあとにしかwaitは存在していない
ということはどっちかというとwaitはfireの付属品であるべきなんだろうね。その方が自然だろ。
複数のactionが同時並行ならwaitCounterも同じ数用意すればいいだけ。
じゃあloopは？
waitとは別でループスタックなるものを用意
loopやrepeatはwaitと違って戻らないからそもそも別扱いするべきだった。ごっちゃにしたのが間違いだった。
waitが関わらなければスタックで処理できるはず・・
waitがfireの付属品っていうのはやめよう。fireの後とは限らないんだった、loopのあとかもだし。
waitは4をセットして次に行くだけの処理にすればOK.
loopに来たら、2をセットして最初に戻ってそれを実行するのだ。で、またwaitに戻ると。
class loopCounter{
  constructor(cur, lim){
    this.current = cur;
    this.limit = lim;
  }
  judge(){
    if(this.current < this.limit){ return false; }
    return true;
  }
  increment(){
    this.current++;
  }
}
loopに来たら(current, limit)をpushして、やめた。

難しくないんだよ。backupに相当することを個別のプロパティでやるだけでしょ。

今の仕様だと{fire1}{wait:4}{fire2}{wait:4}ってやったときに8フレームに2回っていうふうにならないんだよね。
repeatのせい・・工夫で回避できそうだけど。
wait？？
オーケストラってみんなで同じ楽譜を読むでしょ
でも戻る記号とかタイミングまで同じわけじゃないからそういうのを表現したいみたいななんかそういうの。

-------
fireの後は抜けない、loopの後も抜けない、waitのあとは常に抜ける、でいいのね。repeatは？
repeatも点だから（帯じゃないから）抜けない。
それだとseed2で表現しているアレが最初のフレームで無数にブレット作って停止しちゃうだろって？
{wait:1}をはさめば何の問題もない。そこで抜けるから。でしょ？
これでいけるはず。つまり、複数種類の攻撃を決められたターン間隔で発射できる。
-------

あと、repeatにbackupは不要。同じターンの繰り返しなんだから復元するものなんか・・
ああ、repeatは復元するけど・・そうね。
配列使えばいいじゃん。個別に配列用意するの。そこまでやるかって感じだけどまあ・・ね。
backup使う代わりに、それはもう書いてあるから、減らす用で配列作っちゃうわけ。それでいけるはず。
それは、countをもってなければ0, もっていればその値を放り込む形で作られる感じ・・それと別に。
減らすときはそっちを減らす。戻すときはactionから参照して戻す。以上！

_cannon.pattern.actionのところ、まだるっこしいから_cannon.actionってしようよ。わざわざ
patterm経由しなくていい、あとindexは持たせよう。_cannon.currentIndexとかする。

仕様変更をまとめます。

1. action配列のセグメント部分の翻訳について。記法を変えるのです。
actionSeedで配列をやめる。全部オブジェクト記法にする。たとえば、
["shotSpeed", "set", [3, 6]]だったら{speed:["set", [3, 6]]}みたく。
うん、自身のスピード変えながらってのもありよね（回りながらとかね）・・じゃあ{shotSpeed:["set", [3, 6]]}でいこうね。
凡例
{shotSpeed:["set", 4]} {shotSpeed:["set", [5, 6]]} {shotSpeed:["set", [2, 10, 2]]}
{shotDirection:["set", 60]} {shotDirection:["add", 5]} {shotDirection:["add", [0, 20]]}
{fire:"way7"} {shotBehavior:["set", "spiral8"]} {shotBehavior:["clear"]}
{shotAction:["set", "split2"]} {shotAction:["clear"]}
{loop:9, back:-1} {loop:INF, back:5} {wait:60}
{aim:0} {vanish:0} // vanishにカウント付けると何もしないまま流れていってカウント後に消える
// つまり{vanish:60}と{wait:60}{vanish:0}はほぼ同じ、省略記法みたいな。
// aimの数字はマージン、だから以前までの["aim"]は{aim:0}と同じ。
{shotDelay:60}, {shotDelay:[4, 80]}, {shotDelay:0} clearしなくても0で充分。
(speedやdirectionと違いデフォルトがあるので。)
意外と少ないな？

2. 下位のactionも含めた全体の構成について。
{set:{
  position:[], velocity:[], shotVelocity:[], delay:~~, shotdelay:~~
},
action:{
  ptn:[  ,  ,  ,  ],
  fire:{name1:~~, ...},
  behavior:{name1:~~, ...},
  action:{name1:{入れ子でactionが入る感じ}, name2:{}}
},
short:{キー:[置き換わった先の配列]}
}

actionのやつはどっかでなくなる必要があるんだけど・・んー。
自分自身を渡す・・自分と同じactionを渡すっていうのを考えられるんだよね。shotAction:this.actionでOK.
this.actionをいじったものとかでもいける。一部変えるとか。setSelfActionでいけそう。
{shotAction:["set", "self"]}とか？{shotBehavior:[]}
selfの場合は自分自身のactionを使うようにすれば無限複製できるよ・・意味があるかどうかは知らない。
{type:"shotAction", shotAction:"self", limit:3}
selfの場合はセットするときにlimitを参照して

あーーーーそうね。
fireもbehaviorもshortと同じで展開に使うアレなのよね。だったらどこからでも参照できるべきよね。

やり直し。こうしましょう。
{set:{
  position:[], velocity:[], shotVelocity:[], delay:~~, shotdelay:~~
},
action:{
  main:[  ,  ,  ,  ],
  mainの中のshotActionに出てくるselfではない文字列のキー:[](mainのような)
  {shotAction:["set", エイリアス]}とか{shotAction:["clear"]}みたいな。
  出てくるたびに:[]
  出てくるたびに:[]
  すべて書いてね:[] // こうすれば並列処理できるでしょ、頭いい！入れ子やめようぜ。
  入れ子は闇・・
},
short:{キー:[置き換わった先の配列]}
fire:{name1:~~, ...}, // actionの配列に出てくるfireの所に出てくるエイリアスの中身
behavior:{name1:~~, ...}, // の、setBehavior版。
}
まずshortの中の文字列部分をすべて・・Object.keys(short)で順繰りにして、それより後ろですべて復元できるようにする。
だから後ろから見ていって文字列あったらそれより先のもので置き換え、を繰り返せばshortの中から文字列を排除できる。
そうしたら次はactionの中の配列の文字列部分をすべてshort内のそれで置き換える。
次にfireとbehaviorのところを関数化する。
action内のfireとbehavior関連のエイリアス部分をすべてそれで置き換える。
最後に、actionの配列を下から見ていってエイリアスを順繰りにそれより先のaction配列で置き換えていく。
main一本になる。
登録するパターン（完成形）は{x:~~~, y:~~~, (以下続く), action:~~~(mainのやつ)}になる。これでいける。
backupは作らない。createFirePatternの際に各々のbulletにはbackup配列を渡す、というか
cannon(もしくはbullet）のsetActionから1回だけ作ってコピーする。これでいこう。
復元関数recoveryも作る。

3. waitについて。今の仕様だと
fire1 -- wait:4 -- fire2 -- wait:4
のようなときに間が2フレームしか空かないので✕.
こうする。
fireのあとは継続。loopのあとやrepeatのあとも継続。backもきちんと行う。waitのあとだけ、常に抜ける。
こうするとうまくいく。
seed3のようなrepeat2回を毎フレーム延々とやる場合であっても、間に{wait:1}をはさめば、ここで抜けてくれるから
ランタイムエラーにならずに済む。そういうことですね。
・・となるとrepeat要らないな。loopで抜けないなら挙動に差がつかないものね。

4. なんかあったっけ（
まあ、bulletにもactionを実行させる環境は必要よね。
あと、cannonとか、indexはパターンに持たせない。個体に持たせる。バックアップも持たせる。・・・
this.patternとなっているところはどちらもactionに切り替える。patternそれ自体はもう要らないので。
情報は全部actionに入ってるし。
pattern.fireとかpattern.behaviorとかあるけどこれも関数入れちゃうから要らないね。
this.pattern, 廃止！！！！こんなところかな・・明日頑張ってやろう、年が明けちゃう前にやっちゃおう。

// 新しい記法の具体例をあげます。
// こちらは7方向に発射した弾が分かれて、分かれて、直進する感じのやつ。
{set:{
  position:[240, 160], shotVelocity:[2, 90]
 }
 action:{
  main:[{setAction:"next1"}, {shotSpeed:2}, {fire:"radial7"}, {wait:30}, {loop:INF, back:-1}],
  next1:[{wait:30}, {setAction:"next2"}, {fire:"way2"}, {vanish:0}],
  next2:[{wait:30}, {setAction:"next3"}, {fire:"way2"}, {vanish:0}],
  next3:[{wait:30}, {fire:"way2"}, {vanish:0}]
 }
 fire:["way2", {nway:{count:2, interval:120}}], ["radial7", {nway:{count:7}}]
}
とか？
ここにたとえばbehaviorの付与を加えることで曲がりながら飛んでいって分裂、などのバリエーションも可能です。
飛んでいく方向を調節すればきれいな幾何学模様を描くこともできるかもね。

_cannonとかbulletのwaitやらloopのカウントを無くすやつは、そういうメソッドとして確立すればいいのではないかな。
this.backup[this.currentIndex]--; って感じで。んで、0になるならtrueを返す感じにする。
0になるときにindexを増やすので。indexを増やすのも、indexは個別持ちになるからメソッドとして書いた方がいいね。
いよいよ統一するときが来たかな・・
repeat廃止！！！！

backup作り方変える。
countプロパティを持つオブジェクトの数だけ0を用意して、それ専用のインデックスも用意する。
countを持つセグメントに遭遇したら、その箇所のカウントを増やす、
countに達したら、waitの場合はインデックスを増やして抜ける。ループの方のインデックスも増やす。どっちも増やす。
次にbackするときに、戻って行って、count持ちのプロパティに出会ったらループのインデックスをひとつ戻して
そこを0に戻す。それを最後までやる。そうするとそのあとの走査で最初に遭遇するカウントセグメントのところに以下略。
はじめようか。さっさと終わらせよう、明日から忙しいから。
